{% extends "base.html" %}

{% block title %}–¢–µ—Å—Ç —Å—É–Ω–¥—É–∫–∞ - –í–∞–ª–µ—Ä–∞ –≤ –ø–µ—â–µ—Ä–µ{% endblock %}

{% block extra_head %}
<style>
body {
    font-family: 'Comic Sans MS', 'Arial Rounded MT Bold', Arial, sans-serif;
    background: linear-gradient(135deg, #2b2b2b 0%, #1a1a1a 100%);
    min-height: 100vh;
    padding: 16px;
}

.test-container {
    max-width: 900px;
    margin: 20px auto;
    background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
    border-radius: 22px;
    border: 3px solid #c8a2c8;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
    padding: 24px;
}

.test-title {
    text-align: center;
    font-size: 34px;
    margin: 0 0 10px 0;
    color: #8b6fa8;
    text-shadow: 1px 1px 0px #e8d5c4;
}

.test-subtitle {
    text-align: center;
    color: #555;
    margin: 0 0 20px 0;
}

.controls {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    margin: 18px 0 6px 0;
}

.input {
    padding: 12px 14px;
    border-radius: 14px;
    border: 2px solid #a8b8d0;
    min-width: min(520px, 90vw);
    font-size: 16px;
}

.btn {
    background: linear-gradient(135deg, #8b9dc8 0%, #9b8fb8 100%);
    color: white;
    border: none;
    padding: 12px 18px;
    border-radius: 14px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 5px 15px rgba(139, 157, 200, 0.35);
    transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 8px 20px rgba(139, 157, 200, 0.45);
}

.btn.secondary {
    background: linear-gradient(135deg, #d4c5b0 0%, #c8b5a0 100%);
    box-shadow: 0 5px 15px rgba(212, 197, 176, 0.35);
}

/* ===== –ú–æ–¥–∞–ª–∫–∞ (–º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è) ===== */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.72);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    padding: 12px;
}

.modal-overlay.show {
    display: flex;
}

.modal-content {
    background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
    border-radius: 24px;
    padding: 26px;
    max-width: 520px;
    width: 92%;
    position: relative;
    border: 3px solid #c8a2c8;
    box-shadow: 0 12px 50px rgba(0, 0, 0, 0.22);
}

.modal-title {
    color: #8b6fa8;
    font-size: 28px;
    margin: 0 0 12px 0;
    text-align: center;
    font-weight: bold;
    text-shadow: 1px 1px 0px #e8d5c4;
}

.modal-close {
    position: absolute;
    top: 12px;
    right: 12px;
    background: linear-gradient(135deg, #d4a5a5 0%, #c89595 100%);
    border: none;
    color: #fff;
    font-size: 26px;
    cursor: pointer;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    font-weight: bold;
    box-shadow: 0 3px 8px rgba(212, 165, 165, 0.3);
}

/* ===== –°—É–Ω–¥—É–∫ ===== */
.drop-chest-stage {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 18px;
}

.drop-chest-wrap {
    position: relative;
    width: 260px;
    max-width: 70vw;
    display: grid;
    place-items: center;
    padding: 10px;
}

/* —É–±—Ä–∞–ª–∏ —Å–≤–µ—á–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ —Å—É–Ω–¥—É–∫–∞ */

.drop-fireworks {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 2; /* –Ω–∞–¥ —Å—É–Ω–¥—É–∫–æ–º, –ø–æ–¥ —Ç–µ–∫—Å—Ç–æ–º */
}

.drop-chest-wrap.drop-theme-medium img.drop-chest-fallback {
    /* —Å—Ä–µ–¥–Ω–∏–π —à–∞–Ω—Å: –∞–º–µ—Ç–∏—Å—Ç–æ–≤—ã–π */
    filter: hue-rotate(250deg) saturate(1.55) brightness(1.06) contrast(1.08);
}

.drop-chest-wrap.drop-theme-very-low img.drop-chest-fallback {
    /* –Ω–∏–∑–∫–∏–π —à–∞–Ω—Å: –∞–ª–º–∞–∑–Ω—ã–π (—Ü–∏–∞–Ω/–ª–µ–¥—è–Ω–æ–π) */
    filter: hue-rotate(195deg) saturate(2.25) brightness(1.18) contrast(1.12);
}

.drop-chest {
    width: 100%;
    height: auto;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    transform-origin: 50% 80%;
    user-select: none;
    -webkit-user-drag: none;
}

.drop-chest.opening {
    animation: dropChestPop 2000ms ease-in-out;
}

.drop-chest.opened {
    transform: translateY(-4px) scale(1.03);
    filter: drop-shadow(0 10px 25px rgba(255, 215, 0, 0.35)) brightness(1.08);
}

.drop-result {
    position: relative;
    z-index: 3; /* –ø–æ–≤–µ—Ä—Ö —Å–∞–ª—é—Ç–∞ */
    font-size: 20px;
    font-weight: bold;
    color: #333;
    text-align: center;
    opacity: 0;
    transform: translateY(8px) scale(0.98);
    transition: opacity 300ms ease, transform 300ms ease;
    line-height: 1.4;
    padding: 10px 12px;
    border-radius: 14px;
    background: linear-gradient(135deg, rgba(255, 215, 0, 0.25) 0%, rgba(255, 237, 78, 0.25) 100%);
    border: 2px solid rgba(255, 140, 0, 0.45);
    box-shadow: 0 8px 22px rgba(255, 215, 0, 0.12);
}

.drop-result.show {
    opacity: 1;
    transform: translateY(0) scale(1);
}

.drop-subhint {
    text-align: center;
    color: #666;
    font-size: 14px;
}

/* 3D-—Ä–µ–Ω–¥–µ—Ä —Å—É–Ω–¥—É–∫–∞ (three.js) */
.drop-chest-3d {
    width: 100%;
    height: 320px;
    display: block;
}

.drop-chest-3d canvas {
    width: 100% !important;
    height: 100% !important;
    display: block;
    border-radius: 12px;
}

.drop-chest-fallback {
    display: none;
}

#dropChestFallback.waiting {
    display: block;
    animation: dropChestSpin 2000ms linear forwards;
}

#dropChestFallback.opening {
    display: block;
    animation: dropChestPop 2000ms ease-in-out;
}

/* —É–±—Ä–∞–ª–∏ —Å–≤–µ—á–µ–Ω–∏–µ –∏–∑ —Å—É–Ω–¥—É–∫–∞ */

@keyframes dropChestSpin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes dropChestShake {
    0% { transform: translateY(0) rotate(0deg) scale(1); }
    12% { transform: translateY(-1px) rotate(-3deg) scale(1.008); }
    24% { transform: translateY(0) rotate(3deg) scale(1.008); }
    36% { transform: translateY(-1px) rotate(-2.5deg) scale(1.008); }
    48% { transform: translateY(0) rotate(2.5deg) scale(1.008); }
    60% { transform: translateY(-1px) rotate(-1.5deg) scale(1.008); }
    72% { transform: translateY(0) rotate(1.5deg) scale(1.008); }
    84% { transform: translateY(-1px) rotate(-1deg) scale(1.004); }
    100% { transform: translateY(0) rotate(0deg) scale(1); }
}
/* dropChestShake –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è (—Ç—Ä—è—Å–∫–∞ —É–±—Ä–∞–Ω–∞) */

@keyframes dropChestPop {
    0% { filter: drop-shadow(0 0 0 rgba(255, 215, 0, 0)) brightness(1); }
    60% { filter: drop-shadow(0 14px 30px rgba(255, 215, 0, 0.25)) brightness(1.05); }
    100% { filter: drop-shadow(0 10px 25px rgba(255, 215, 0, 0.35)) brightness(1.08); }
}
</style>
{% endblock %}

{% block content %}
<div class="test-container">
    <h1 class="test-title">–¢–µ—Å—Ç: –∞–Ω–∏–º–∞—Ü–∏—è —Å—É–Ω–¥—É–∫–∞</h1>
    <p class="test-subtitle">–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É ‚Äî –ø–æ—è–≤–∏—Ç—Å—è —Å—É–Ω–¥—É–∫, –ø—Ä–æ–∏–≥—Ä–∞–µ—Ç—Å—è –∞–Ω–∏–º–∞—Ü–∏—è –∏ –ø–æ–∫–∞–∂–µ—Ç—Å—è ¬´—á—Ç–æ –≤—ã–ø–∞–ª–æ¬ª.</p>

    <div class="controls">
        <input id="dropInput" class="input" type="text" value="–ö–æ–ª—å—Ü–æ —Å–∏–ª—ã +1" maxlength="200">
        <select id="dropProbability" class="input" style="min-width: 240px;">
            <option value="high">–í—ã—Å–æ–∫–∏–π —à–∞–Ω—Å (–æ–±—ã—á–Ω—ã–π)</option>
            <option value="medium" selected>–°—Ä–µ–¥–Ω–∏–π —à–∞–Ω—Å</option>
            <option value="very_low">–ù–∏–∑–∫–∏–π —à–∞–Ω—Å (–∞–ª–º–∞–∑–Ω—ã–π)</option>
        </select>
        <button class="btn" id="openBtn" type="button">–°–∏–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –¥—Ä–æ–ø</button>
        <button class="btn secondary" id="randomBtn" type="button">–°–ª—É—á–∞–π–Ω—ã–π –¥—Ä–æ–ø</button>
    </div>
</div>

<div class="modal-overlay" id="dropModal">
    <div class="modal-content">
        <button class="modal-close" type="button" onclick="closeDropModal()">&times;</button>
        <h2 class="modal-title" id="dropTitle">üéÅ –î—Ä–æ–ø –ø–æ–ª—É—á–µ–Ω!</h2>
        <div class="drop-chest-stage">
            <div class="drop-chest-wrap" id="dropChestWrap" role="button" tabindex="0" aria-label="–û—Ç–∫—Ä—ã—Ç—å —Å—É–Ω–¥—É–∫">
                <div id="dropChest" class="drop-chest drop-chest-3d" aria-hidden="true"></div>
                <img id="dropChestFallback" class="drop-chest drop-chest-fallback" src="{{ url_for('static', filename='box.png') }}" alt="–°—É–Ω–¥—É–∫">
                <canvas id="dropFireworks" class="drop-fireworks" aria-hidden="true"></canvas>
                <div class="drop-result" id="dropResult"></div>
            </div>
            <div class="drop-subhint">–°—É–Ω–¥—É–∫ –æ—Ç–∫—Ä–æ–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏‚Ä¶ (–∏–ª–∏ –∫–ª–∏–∫–Ω–∏—Ç–µ –ø–æ –Ω–µ–º—É)</div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
const DROP_AUTO_OPEN_DELAY_MS = 2000; // –æ–∂–∏–¥–∞–Ω–∏–µ –ø–µ—Ä–µ–¥ –æ—Ç–∫—Ä—ã—Ç–∏–µ–º
const DROP_OPEN_ANIMATION_MS = 2000;  // –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ—Ç–∫—Ä—ã—Ç–∏—è
let dropStartOpenTimeoutId = null;
let dropRevealTimeoutId = null;
let dropChest3D = null;
let dropFireworks = null;

function normalizeDropProbability(value) {
    const raw = String(value ?? '').trim().toLowerCase();
    if (!raw) return 'high';
    if (raw === 'very_low' || raw === 'very-low' || raw === 'low' || raw === '–Ω–∏–∑–∫–∏–π' || raw === '–Ω–∏–∑–∫–∞—è' || raw.includes('–æ—á–µ–Ω—å')) return 'very_low';
    if (raw === 'medium' || raw === '—Å—Ä–µ–¥–Ω–∏–π' || raw === '—Å—Ä–µ–¥–Ω—è—è') return 'medium';
    return 'high';
}

function applyDropThemeToDom(chestWrap, probability) {
    if (!chestWrap) return;
    chestWrap.classList.remove('drop-theme-high', 'drop-theme-medium', 'drop-theme-very-low');
    const p = normalizeDropProbability(probability);
    const cls = p === 'very_low' ? 'drop-theme-very-low' : `drop-theme-${p}`;
    chestWrap.classList.add(cls);
}

function clearDropTheme(chestWrap) {
    if (!chestWrap) return;
    chestWrap.classList.remove('drop-theme-high', 'drop-theme-medium', 'drop-theme-very-low');
}

function createChestFireworks(canvas) {
    const ctx = canvas.getContext('2d', { alpha: true });
    if (!ctx) return null;

    let running = false;
    let rafId = null;
    let lastTs = 0;
    let w = 1;
    let h = 1;
    let dpr = 1;
    let ro = null;

    const rockets = [];
    const particles = [];

    const COLORS = [
        [255, 90, 90],
        [255, 214, 102],
        [125, 211, 252],
        [167, 243, 208],
        [196, 181, 253],
        [252, 165, 165]
    ];

    const rand = (min, max) => min + Math.random() * (max - min);
    const pickColor = () => COLORS[Math.floor(Math.random() * COLORS.length)];

    function resize() {
        const cw = Math.max(1, canvas.clientWidth);
        const ch = Math.max(1, canvas.clientHeight);
        dpr = Math.min(window.devicePixelRatio || 1, 2);
        w = cw;
        h = ch;
        canvas.width = Math.round(cw * dpr);
        canvas.height = Math.round(ch * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function explode(x, y, base) {
        const count = Math.floor(rand(26, 38));
        for (let i = 0; i < count; i++) {
            const a = (Math.PI * 2 * i) / count + rand(-0.15, 0.15);
            const sp = rand(1.8, 3.6);
            particles.push({
                x,
                y,
                vx: Math.cos(a) * sp,
                vy: Math.sin(a) * sp,
                g: rand(2.6, 3.4),
                life: rand(0.75, 1.25),
                age: 0,
                r: base.r,
                gC: base.g,
                b: base.b
            });
        }
    }

    function launch(originX, originY) {
        const [r, g, b] = pickColor();
        rockets.push({
            x: originX,
            y: originY,
            vx: rand(-0.35, 0.35),
            vy: rand(-6.2, -7.6),
            t: 0,
            explodeAt: rand(0.48, 0.68),
            r, g, b
        });
    }

    function step(ts) {
        if (!running) return;
        if (!lastTs) lastTs = ts;
        const dt = Math.min(34, ts - lastTs) / 1000;
        lastTs = ts;

        ctx.clearRect(0, 0, w, h);

        // –†–∞–∫–µ—Ç—ã (–≤—ã—Å—Ç—Ä–µ–ª—ã)
        for (let i = rockets.length - 1; i >= 0; i--) {
            const r = rockets[i];
            r.t += dt;
            r.vy += 5.0 * dt;
            r.x += r.vx * 60 * dt;
            r.y += r.vy * 60 * dt;

            ctx.globalCompositeOperation = 'lighter';
            ctx.strokeStyle = `rgba(${r.r},${r.g},${r.b},0.65)`;
            ctx.lineWidth = 2.0;
            ctx.beginPath();
            ctx.moveTo(r.x, r.y);
            ctx.lineTo(r.x - r.vx * 22, r.y - r.vy * 0.5);
            ctx.stroke();
            ctx.globalCompositeOperation = 'source-over';

            if (r.t >= r.explodeAt || r.vy > -1.0) {
                explode(r.x, r.y, r);
                rockets.splice(i, 1);
            }
        }

        // –í—Å–ø—ã—à–∫–∏
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.age += dt;
            const k = Math.max(0, 1 - p.age / p.life);
            p.vy += p.g * 60 * dt * 0.06;
            p.x += p.vx * 60 * dt;
            p.y += p.vy * 60 * dt;

            ctx.fillStyle = `rgba(${p.r},${p.gC},${p.b},${0.9 * k})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2.2, 0, Math.PI * 2);
            ctx.fill();

            if (p.age >= p.life || p.y > h + 40 || p.x < -40 || p.x > w + 40) {
                particles.splice(i, 1);
            }
        }

        if (rockets.length === 0 && particles.length === 0) {
            stop();
            return;
        }

        rafId = requestAnimationFrame(step);
    }

    function start() {
        if (running) return;
        running = true;
        lastTs = 0;
        resize();
        ro = new ResizeObserver(() => resize());
        ro.observe(canvas);
        rafId = requestAnimationFrame(step);
    }

    function stop() {
        running = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;
        lastTs = 0;
        rockets.length = 0;
        particles.length = 0;
        try { ro?.disconnect?.(); } catch (e) { /* noop */ }
        ro = null;
        try { ctx.clearRect(0, 0, w, h); } catch (e) { /* noop */ }
    }

    function shootFromChest() {
        start();
        const ox = w * 0.5;
        const oy = h * 0.52; // –ø—Ä–∏–º–µ—Ä–Ω–æ ‚Äú–∏–∑–Ω—É—Ç—Ä–∏‚Äù —Å—É–Ω–¥—É–∫–∞
        launch(ox + rand(-6, 6), oy);
        setTimeout(() => launch(ox + rand(-10, 10), oy), 120);
        setTimeout(() => launch(ox + rand(-8, 8), oy), 240);
    }

    return { start, stop, shootFromChest };
}

function stopDropFireworks() {
    try { dropFireworks?.stop?.(); } catch (e) { /* noop */ }
    dropFireworks = null;
}

function playDropFireworks() {
    const canvas = document.getElementById('dropFireworks');
    if (!canvas) return;
    stopDropFireworks();
    dropFireworks = createChestFireworks(canvas);
    dropFireworks?.shootFromChest?.();
}

function initDropChest3D() {
    const container = document.getElementById('dropChest');
    const fallback = document.getElementById('dropChestFallback');

    if (!container) return;
    if (!window.THREE) {
        if (fallback) fallback.style.display = 'block';
        container.style.display = 'none';
        return;
    }

    try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) throw new Error('no-webgl');
    } catch (e) {
        if (fallback) fallback.style.display = 'block';
        container.style.display = 'none';
        return;
    }

    if (dropChest3D) return;

    const THREE = window.THREE;
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 100);
    camera.position.set(0, 2.35, 6.2);
    camera.lookAt(0, 0.25, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    container.innerHTML = '';
    container.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x2b2b2b, 1.05);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(3.5, 6, 4);
    scene.add(dir);

    const woodLightMat = new THREE.MeshStandardMaterial({ color: 0xb6763a, roughness: 0.85, metalness: 0.03, flatShading: true });
    const woodDarkMat = new THREE.MeshStandardMaterial({ color: 0x7b4b24, roughness: 0.9, metalness: 0.02, flatShading: true });
    const metalGoldMat = new THREE.MeshStandardMaterial({ color: 0xf2c14e, roughness: 0.35, metalness: 0.65, flatShading: true });
    const metalDarkMat = new THREE.MeshStandardMaterial({ color: 0x5b4b22, roughness: 0.55, metalness: 0.35, flatShading: true });
    const outlineMat = new THREE.MeshBasicMaterial({ color: 0x1b1b1b, side: THREE.BackSide });

    // –¢–µ–º–∞ —Å—É–Ω–¥—É–∫–∞ –ø–æ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ –¥—Ä–æ–ø–∞
    const CHEST_THEMES = {
        high: {
            woodLight: 0xb6763a,
            woodDark: 0x7b4b24,
            metalMain: 0xf2c14e,
            metalMainRough: 0.35,
            metalMainMetal: 0.65,
            metalDark: 0x5b4b22,
            metalDarkRough: 0.55,
            metalDarkMetal: 0.35
        },
        medium: {
            // –∞–º–µ—Ç–∏—Å—Ç–æ–≤—ã–π —Å—É–Ω–¥—É–∫
            woodLight: 0x9b59b6,
            woodDark: 0x5b2c6f,
            metalMain: 0xcbd5e1,   // —Å–µ—Ä–µ–±—Ä–æ
            metalMainRough: 0.28,
            metalMainMetal: 0.78,
            metalDark: 0x334155,
            metalDarkRough: 0.45,
            metalDarkMetal: 0.6
        },
        very_low: {
            // –∞–ª–º–∞–∑–Ω—ã–π —Å—É–Ω–¥—É–∫ (–ª–µ–¥—è–Ω–æ–π —Ü–∏–∞–Ω)
            woodLight: 0x67e8f9,
            woodDark: 0x0284c7,
            metalMain: 0xf8fafc,
            metalMainRough: 0.16,
            metalMainMetal: 0.92,
            metalDark: 0x22d3ee,
            metalDarkRough: 0.24,
            metalDarkMetal: 0.78
        }
    };

    function applyChestTheme(probability) {
        const p = normalizeDropProbability(probability);
        const t = CHEST_THEMES[p] || CHEST_THEMES.high;
        woodLightMat.color.setHex(t.woodLight);
        woodDarkMat.color.setHex(t.woodDark);
        metalGoldMat.color.setHex(t.metalMain);
        metalGoldMat.roughness = t.metalMainRough;
        metalGoldMat.metalness = t.metalMainMetal;
        metalDarkMat.color.setHex(t.metalDark);
        metalDarkMat.roughness = t.metalDarkRough;
        metalDarkMat.metalness = t.metalDarkMetal;
    }

    applyChestTheme('high');

    const addOutline = (mesh, scale = 1.045) => {
        const outline = new THREE.Mesh(mesh.geometry, outlineMat);
        outline.scale.set(scale, scale, scale);
        mesh.add(outline);
    };

    const chestGroup = new THREE.Group();
    scene.add(chestGroup);

    const pad = new THREE.Mesh(
        new THREE.CylinderGeometry(1.85, 1.95, 0.22, 28),
        new THREE.MeshStandardMaterial({ color: 0x2b2b2b, roughness: 0.9, metalness: 0.0, flatShading: true })
    );
    pad.position.y = -0.82;
    addOutline(pad, 1.02);
    chestGroup.add(pad);

    const padTop = new THREE.Mesh(
        new THREE.CylinderGeometry(1.75, 1.85, 0.06, 28),
        new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.85, metalness: 0.0, flatShading: true })
    );
    padTop.position.y = -0.70;
    addOutline(padTop, 1.02);
    chestGroup.add(padTop);

    const shadow = new THREE.Mesh(
        new THREE.CircleGeometry(1.35, 28),
        new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.18 })
    );
    shadow.rotation.x = -Math.PI / 2;
    shadow.position.y = -0.60;
    chestGroup.add(shadow);

    // —Å–≤–µ—á–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é

    const OUTER_W = 2.28;
    const OUTER_H = 0.96;
    const OUTER_D = 1.56;
    const BASE_CENTER_Y = -0.02;
    const WALL_THICK = 0.14;
    const FLOOR_THICK = 0.14;
    const LINER_THICK = 0.02;

    const innerW = OUTER_W - 2 * WALL_THICK;
    const innerD = OUTER_D - 2 * WALL_THICK;
    const wallH = OUTER_H - FLOOR_THICK;
    const bottomY = BASE_CENTER_Y - OUTER_H / 2;
    const floorY = bottomY + FLOOR_THICK / 2;
    const wallY = bottomY + FLOOR_THICK + wallH / 2;

    const interiorMat = new THREE.MeshStandardMaterial({
        color: 0x2a1a0f,
        roughness: 0.98,
        metalness: 0.0,
        flatShading: true,
        // –≤–∞–∂–Ω–æ: –≤–Ω—É—Ç—Ä–µ–Ω–Ω–æ—Å—Ç–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤–∏–¥–Ω—ã –∏–∑–Ω—É—Ç—Ä–∏/–ø–æ–¥ —É–≥–ª–∞–º–∏
        side: THREE.DoubleSide
    });

    const floorOuter = new THREE.Mesh(new THREE.BoxGeometry(innerW, FLOOR_THICK, innerD), woodLightMat);
    floorOuter.position.set(0, floorY, 0);
    chestGroup.add(floorOuter);

    const wallFrontOuter = new THREE.Mesh(new THREE.BoxGeometry(innerW, wallH, WALL_THICK), woodLightMat);
    wallFrontOuter.position.set(0, wallY, OUTER_D / 2 - WALL_THICK / 2);
    chestGroup.add(wallFrontOuter);

    const wallBackOuter = wallFrontOuter.clone();
    wallBackOuter.position.z = -OUTER_D / 2 + WALL_THICK / 2;
    chestGroup.add(wallBackOuter);

    const wallLeftOuter = new THREE.Mesh(new THREE.BoxGeometry(WALL_THICK, wallH, innerD), woodLightMat);
    wallLeftOuter.position.set(-OUTER_W / 2 + WALL_THICK / 2, wallY, 0);
    chestGroup.add(wallLeftOuter);

    const wallRightOuter = wallLeftOuter.clone();
    wallRightOuter.position.x = OUTER_W / 2 - WALL_THICK / 2;
    chestGroup.add(wallRightOuter);

    const floorInner = new THREE.Mesh(new THREE.BoxGeometry(innerW, LINER_THICK, innerD), interiorMat);
    floorInner.position.set(0, floorY + FLOOR_THICK / 2 + LINER_THICK / 2 + 0.002, 0);
    chestGroup.add(floorInner);

    const innerFront = new THREE.Mesh(new THREE.BoxGeometry(innerW, wallH, LINER_THICK), interiorMat);
    innerFront.position.set(0, wallY, OUTER_D / 2 - WALL_THICK - LINER_THICK / 2 - 0.002);
    chestGroup.add(innerFront);

    const innerBack = innerFront.clone();
    innerBack.position.z = -OUTER_D / 2 + WALL_THICK + LINER_THICK / 2 + 0.002;
    chestGroup.add(innerBack);

    const innerLeft = new THREE.Mesh(new THREE.BoxGeometry(LINER_THICK, wallH, innerD), interiorMat);
    innerLeft.position.set(-OUTER_W / 2 + WALL_THICK + LINER_THICK / 2 + 0.002, wallY, 0);
    chestGroup.add(innerLeft);

    const innerRight = innerLeft.clone();
    innerRight.position.x = OUTER_W / 2 - WALL_THICK - LINER_THICK / 2 - 0.002;
    chestGroup.add(innerRight);

    const RIM_W = OUTER_W + 0.06;
    const RIM_D = OUTER_D + 0.06;
    const RIM_H = 0.12;
    const RIM_T = 0.12;
    const rimY = bottomY + OUTER_H - RIM_H / 2;

    const rimFront = new THREE.Mesh(new THREE.BoxGeometry(RIM_W, RIM_H, RIM_T), woodDarkMat);
    rimFront.position.set(0, rimY, RIM_D / 2 - RIM_T / 2);
    addOutline(rimFront, 1.03);
    chestGroup.add(rimFront);

    const rimBack = rimFront.clone();
    rimBack.position.z = -RIM_D / 2 + RIM_T / 2;
    chestGroup.add(rimBack);

    const rimSideGeo = new THREE.BoxGeometry(RIM_T, RIM_H, RIM_D - 2 * RIM_T);
    const rimLeft = new THREE.Mesh(rimSideGeo, woodDarkMat);
    rimLeft.position.set(-RIM_W / 2 + RIM_T / 2, rimY, 0);
    addOutline(rimLeft, 1.03);
    chestGroup.add(rimLeft);

    const rimRight = rimLeft.clone();
    rimRight.position.x = RIM_W / 2 - RIM_T / 2;
    chestGroup.add(rimRight);

    const baseBottomRim = new THREE.Mesh(new THREE.BoxGeometry(2.34, 0.12, 1.62), woodDarkMat);
    baseBottomRim.position.set(0, -0.50, 0);
    addOutline(baseBottomRim);
    chestGroup.add(baseBottomRim);

    const frontPanel = new THREE.Mesh(new THREE.BoxGeometry(1.92, 0.58, 0.06), woodDarkMat);
    frontPanel.position.set(0, -0.06, 0.79);
    addOutline(frontPanel, 1.035);
    chestGroup.add(frontPanel);

    const sidePanelL = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.58, 1.34), woodDarkMat);
    sidePanelL.position.set(-1.14, -0.06, 0);
    addOutline(sidePanelL, 1.035);
    chestGroup.add(sidePanelL);

    const sidePanelR = sidePanelL.clone();
    sidePanelR.position.x = 1.14;
    chestGroup.add(sidePanelR);

    const footGeo = new THREE.BoxGeometry(0.26, 0.18, 0.26);
    const footPositions = [
        [-0.95, -0.62, 0.62],
        [0.95, -0.62, 0.62],
        [-0.95, -0.62, -0.62],
        [0.95, -0.62, -0.62]
    ];
    footPositions.forEach(([x, y, z]) => {
        const foot = new THREE.Mesh(footGeo, woodDarkMat);
        foot.position.set(x, y, z);
        addOutline(foot, 1.04);
        chestGroup.add(foot);
    });

    const cornerGeo = new THREE.BoxGeometry(0.16, 0.72, 0.16);
    const cornerPositions = [
        [-1.12, -0.08, 0.76],
        [1.12, -0.08, 0.76],
        [-1.12, -0.08, -0.76],
        [1.12, -0.08, -0.76]
    ];
    cornerPositions.forEach(([x, y, z]) => {
        const corner = new THREE.Mesh(cornerGeo, metalDarkMat);
        corner.position.set(x, y, z);
        addOutline(corner, 1.03);
        chestGroup.add(corner);
    });

    const bandV = new THREE.Mesh(new THREE.BoxGeometry(0.26, 1.02, 0.10), metalGoldMat);
    bandV.position.set(0, -0.02, 0.79);
    addOutline(bandV, 1.03);
    chestGroup.add(bandV);

    const bandTop = new THREE.Mesh(new THREE.BoxGeometry(2.36, 0.08, 0.10), metalGoldMat);
    bandTop.position.set(0, 0.24, 0.79);
    addOutline(bandTop, 1.03);
    chestGroup.add(bandTop);

    const bandBottom = new THREE.Mesh(new THREE.BoxGeometry(2.36, 0.08, 0.10), metalGoldMat);
    bandBottom.position.set(0, -0.40, 0.79);
    addOutline(bandBottom, 1.03);
    chestGroup.add(bandBottom);

    const lockPlate = new THREE.Mesh(new THREE.BoxGeometry(0.44, 0.34, 0.10), metalDarkMat);
    lockPlate.position.set(0, 0.02, 0.86);
    addOutline(lockPlate, 1.03);
    chestGroup.add(lockPlate);

    const lockBody = new THREE.Mesh(new THREE.BoxGeometry(0.26, 0.26, 0.12), metalGoldMat);
    lockBody.position.set(0, 0.02, 0.92);
    addOutline(lockBody, 1.03);
    chestGroup.add(lockBody);

    const lockTongue = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.16, 0.06), metalGoldMat);
    lockTongue.position.set(0, -0.12, 0.95);
    addOutline(lockTongue, 1.03);
    chestGroup.add(lockTongue);

    const lidPivot = new THREE.Group();
    lidPivot.position.set(0, 0.44, -0.78);
    chestGroup.add(lidPivot);

    const lidBase = new THREE.Mesh(new THREE.BoxGeometry(2.28, 0.22, 1.56), woodLightMat);
    lidBase.position.set(0, 0.11, 0.78);
    addOutline(lidBase);
    lidPivot.add(lidBase);

    const lidCurveGeo = new THREE.CylinderGeometry(0.78, 0.78, 2.28, 18, 1, false, 0, Math.PI);
    const lidCurve = new THREE.Mesh(lidCurveGeo, woodDarkMat);
    lidCurve.rotation.z = Math.PI / 2;
    lidCurve.rotation.y = Math.PI;
    lidCurve.position.set(0, 0.32, 0.78);
    addOutline(lidCurve, 1.03);
    lidPivot.add(lidCurve);

    // –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Å—Ç–æ—Ä–æ–Ω–∞ –∫—Ä—ã—à–∫–∏ (—á—Ç–æ–±—ã —Å—É–Ω–¥—É–∫ –≤—ã–≥–ª—è–¥–µ–ª –ø–æ–ª—ã–º –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏)
    const lidInnerBase = new THREE.Mesh(
        new THREE.BoxGeometry(2.28 - 2 * WALL_THICK, LINER_THICK, 1.56 - 2 * WALL_THICK),
        interiorMat
    );
    // –Ω–∏–∑ –∫—Ä—ã—à–∫–∏ –æ–∫–æ–ª–æ –ª–∏–Ω–∏–∏ —Å—Ç—ã–∫–∞ —Å –æ—Å–Ω–æ–≤–∞–Ω–∏–µ–º
    lidInnerBase.position.set(0, 0.02, 0.78);
    lidPivot.add(lidInnerBase);

    const lidInnerCurveGeo = new THREE.CylinderGeometry(0.74, 0.74, 2.20, 16, 1, false, 0, Math.PI);
    const lidInnerCurve = new THREE.Mesh(lidInnerCurveGeo, interiorMat);
    lidInnerCurve.rotation.z = Math.PI / 2;
    lidInnerCurve.rotation.y = Math.PI;
    lidInnerCurve.position.set(0, 0.30, 0.78);
    lidPivot.add(lidInnerCurve);

    const lidBand = new THREE.Mesh(new THREE.BoxGeometry(0.26, 0.62, 0.10), metalGoldMat);
    lidBand.position.set(0, 0.22, 1.00);
    addOutline(lidBand, 1.03);
    lidPivot.add(lidBand);

    const lidFrontLip = new THREE.Mesh(new THREE.BoxGeometry(2.36, 0.10, 0.10), metalDarkMat);
    lidFrontLip.position.set(0, 0.08, 1.55);
    addOutline(lidFrontLip, 1.03);
    lidPivot.add(lidFrontLip);

    const hingeGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.34, 10);
    const hingeL = new THREE.Mesh(hingeGeo, metalDarkMat);
    hingeL.rotation.z = Math.PI / 2;
    hingeL.position.set(-0.72, 0.06, -0.02);
    addOutline(hingeL, 1.03);
    lidPivot.add(hingeL);

    const hingeR = hingeL.clone();
    hingeR.position.x = 0.72;
    lidPivot.add(hingeR);

    let rafId = null;
    let visible = false;
    let openingStart = null;
    let openingDuration = DROP_OPEN_ANIMATION_MS;
    let opened = false;
    let rotating = false;
    let rotateStart = null;
    const ROTATE_DURATION_MS = DROP_AUTO_OPEN_DELAY_MS;
    let baseRotY = 0;
    let baseRotX = 0.10;
    let baseY = -0.06;
    // —Å–≤–µ—á–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é

    const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

    function renderFrame(now) {
        if (!visible) return;

        if (rotating && !opened && openingStart === null) {
            if (rotateStart === null) rotateStart = now;
            const elapsed = now - rotateStart;
            const t = Math.max(0, Math.min(1, elapsed / ROTATE_DURATION_MS));
            chestGroup.rotation.y = baseRotY + (Math.PI * 2) * t;
            if (t >= 1) {
                rotating = false;
                rotateStart = null;
                chestGroup.rotation.y = baseRotY;
            }
        } else {
            rotateStart = null;
            chestGroup.rotation.y = baseRotY;
        }

        chestGroup.rotation.x = baseRotX;
        chestGroup.rotation.z = 0;
        chestGroup.position.x = 0;
        chestGroup.position.y = baseY;

        if (openingStart !== null && !opened) {
            const t = Math.min(1, (now - openingStart) / openingDuration);
            const k = easeOutCubic(t);
            lidPivot.rotation.x = -Math.PI * 0.62 * k;
            if (t >= 1) {
                opened = true;
                openingStart = null;
            }
        }

        // —Å–≤–µ—á–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é

        renderer.render(scene, camera);
        rafId = requestAnimationFrame(renderFrame);
    }

    function resize() {
        const w = Math.max(1, container.clientWidth);
        const h = Math.max(1, container.clientHeight);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h, false);
    }

    const ro = new ResizeObserver(() => resize());
    ro.observe(container);
    resize();

    if (fallback) fallback.style.display = 'none';
    container.style.display = 'block';

    dropChest3D = {
        show() {
            visible = true;
            if (!rafId) rafId = requestAnimationFrame(renderFrame);
        },
        hide() {
            visible = false;
            if (rafId) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }
        },
        reset() {
            opened = false;
            openingStart = null;
            rotating = false;
            rotateStart = null;
            // —Å–≤–µ—á–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é
            lidPivot.rotation.x = 0;
            chestGroup.rotation.y = baseRotY;
            chestGroup.rotation.x = baseRotX;
            chestGroup.rotation.z = 0;
            chestGroup.position.set(0, baseY, 0);
            // —Å–≤–µ—á–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é
            renderer.render(scene, camera);
        },
        startRotate() {
            rotating = true;
            rotateStart = null;
        },
        stopRotate() {
            rotating = false;
            rotateStart = null;
            baseRotY = 0;
            chestGroup.rotation.y = baseRotY;
        },
        startOpen(ms = DROP_OPEN_ANIMATION_MS) {
            openingDuration = ms;
            opened = false;
            openingStart = performance.now();
            // —Å–≤–µ—á–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é
        },
        openInstant() {
            opened = true;
            openingStart = null;
            lidPivot.rotation.x = -Math.PI * 0.62;
            renderer.render(scene, camera);
        },
        setTheme(probability) {
            applyChestTheme(probability);
            renderer.render(scene, camera);
        }
    };
}

function closeDropModal() {
    const dropModal = document.getElementById('dropModal');
    const chest = document.getElementById('dropChest');
    const chestWrap = document.getElementById('dropChestWrap');
    const result = document.getElementById('dropResult');
    if (dropStartOpenTimeoutId) {
        clearTimeout(dropStartOpenTimeoutId);
        dropStartOpenTimeoutId = null;
    }
    if (dropRevealTimeoutId) {
        clearTimeout(dropRevealTimeoutId);
        dropRevealTimeoutId = null;
    }

    stopDropFireworks();

    if (dropModal) dropModal.classList.remove('show');
    if (chest) chest.classList.remove('opening', 'opened');
    if (chestWrap) {
        chestWrap.classList.remove('opened');
        clearDropTheme(chestWrap);
    }
    if (result) {
        result.textContent = '';
        result.classList.remove('show');
    }
    const fallback = document.getElementById('dropChestFallback');
    if (fallback) {
        fallback.classList.remove('waiting', 'opening');
    }

    try {
        dropChest3D?.hide?.();
    } catch (e) {
        // noop
    }
}

function showDropChest(dropName, probability = 'high') {
    const dropModal = document.getElementById('dropModal');
    const title = document.getElementById('dropTitle');
    const chest = document.getElementById('dropChest');
    const chestWrap = document.getElementById('dropChestWrap');
    const result = document.getElementById('dropResult');
    if (!dropModal || !title || !chest || !chestWrap || !result) return;

    if (dropStartOpenTimeoutId) {
        clearTimeout(dropStartOpenTimeoutId);
        dropStartOpenTimeoutId = null;
    }
    if (dropRevealTimeoutId) {
        clearTimeout(dropRevealTimeoutId);
        dropRevealTimeoutId = null;
    }

    stopDropFireworks();

    title.textContent = 'üéÅ –î—Ä–æ–ø –ø–æ–ª—É—á–µ–Ω!';
    result.textContent = '';
    result.classList.remove('show');
    chest.classList.remove('opening', 'opened');
    chestWrap.classList.remove('opened');
    applyDropThemeToDom(chestWrap, probability);
    const fallback = document.getElementById('dropChestFallback');
    if (fallback) {
        fallback.classList.remove('waiting', 'opening');
    }

    dropModal.classList.add('show');

    try {
        initDropChest3D();
        dropChest3D?.setTheme?.(probability);
        dropChest3D?.reset?.();
        dropChest3D?.show?.();
        dropChest3D?.startRotate?.();
    } catch (e) {
        // noop
    }

    if (fallback && fallback.style.display === 'block') {
        fallback.classList.add('waiting');
    }

    const reveal = () => {
        chest.classList.add('opened');
        chestWrap.classList.add('opened');
        result.textContent = `–í—ã–ø–∞–ª–æ: ${dropName}`;
        result.classList.add('show');
        playDropFireworks();
    };

    const startOpenAnimation = () => {
        try {
            dropChest3D?.stopRotate?.();
        } catch (e) {
            // noop
        }
        if (fallback) {
            fallback.classList.remove('waiting');
            fallback.classList.add('opening');
        }

        void chest.offsetWidth;
        chest.classList.add('opening');
        try {
            dropChest3D?.startOpen?.(DROP_OPEN_ANIMATION_MS);
        } catch (e) {
            // noop
        }
        // —Å–≤–µ—á–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é
        dropRevealTimeoutId = setTimeout(reveal, DROP_OPEN_ANIMATION_MS);
    };

    // –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ "–æ—Ç–∫—Ä—ã–≤–∞–µ–º" —Å—É–Ω–¥—É–∫: –∑–∞–¥–µ—Ä–∂–∫–∞ -> –∞–Ω–∏–º–∞—Ü–∏—è -> —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    dropStartOpenTimeoutId = setTimeout(startOpenAnimation, DROP_AUTO_OPEN_DELAY_MS);

    const openNow = () => {
        if (dropStartOpenTimeoutId) {
            clearTimeout(dropStartOpenTimeoutId);
            dropStartOpenTimeoutId = null;
        }
        if (dropRevealTimeoutId) {
            clearTimeout(dropRevealTimeoutId);
            dropRevealTimeoutId = null;
        }
        if (fallback) {
            fallback.classList.remove('waiting', 'opening');
        }
        try { dropChest3D?.stopRotate?.(); } catch (e) { /* noop */ }
        try {
            dropChest3D?.openInstant?.();
        } catch (e) {
            // noop
        }
        reveal();
    };

    chestWrap.onclick = openNow;
    chestWrap.onkeydown = (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            openNow();
        }
    };
}

document.addEventListener('DOMContentLoaded', () => {
    const openBtn = document.getElementById('openBtn');
    const randomBtn = document.getElementById('randomBtn');
    const dropInput = document.getElementById('dropInput');
    const dropProbability = document.getElementById('dropProbability');
    const dropModal = document.getElementById('dropModal');

    const demoDrops = [
        '–ö–æ–ª—å—Ü–æ —Å–∏–ª—ã +1',
        '–°–≤–∏—Ç–æ–∫ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞',
        '100 –º–æ–Ω–µ—Ç',
        '–ú–µ—á —É—á–µ–Ω–∏–∫–∞',
        '–≠–ø–∏—á–µ—Å–∫–∏–π ¬´–Ω–∏—á–µ–≥–æ¬ª'
    ];

    const getValue = () => (dropInput?.value || '').trim() || '–¢–µ—Å—Ç–æ–≤—ã–π –¥—Ä–æ–ø';
    const getProb = () => dropProbability?.value || 'high';

    if (openBtn) {
        openBtn.addEventListener('click', () => showDropChest(getValue(), getProb()));
    }

    if (randomBtn) {
        randomBtn.addEventListener('click', () => {
            const randomDrop = demoDrops[Math.floor(Math.random() * demoDrops.length)];
            const probs = ['high', 'medium', 'very_low'];
            const randomProb = probs[Math.floor(Math.random() * probs.length)];
            if (dropInput) dropInput.value = randomDrop;
            if (dropProbability) dropProbability.value = randomProb;
            showDropChest(randomDrop, randomProb);
        });
    }

    if (dropModal) {
        dropModal.addEventListener('click', (e) => {
            if (e.target === dropModal) closeDropModal();
        });
    }

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            const isOpen = dropModal?.classList.contains('show');
            if (isOpen) closeDropModal();
        }
    });
});
</script>
{% endblock %}

